version 0.9.20:
	It's 3 am the night before finals, it's obviously a good time to hack
	gaim.

	The first thing to note is that there are about 9 new events plugins
	can attach to, most of them dealing with chat, since I know that was a
	big thing that was missing. Please note that I was nice and decided to
	tack these extra events onto the end of the enum, which means that
	plugins do not have to be recompiled in order for them to still work.

	The big thing to note is that gaim_plugin_init no longer returns void,
	but int.  If it returns 1, gaim interprets this as there being no
	error, and continues with loading as normal. (This should be backwards-
	compatible: returning 1 is the equivalent of returning void.) If it
	returns a non-zero number, there was an error loading detected by the
	plugin. At that point, gaim will try to clean things up by removing any
	callbacks that have been added by the plugin. It will then try to call
	the plugin's gaim_plugin_error function, if there is one. The function
	should take an int (the int returned by gaim_plugin_init) and return a
	char*. If the char* is not NULL, it is displayed by gaim as an error
	message.  The plugin is then unloaded and closed and life goes back to
	normal. If any of that was confusing, it was confusing to me, too. I
	added a plugin, error.c, which should help clear things up.

	There is a new event, event_quit, which signifies that gaim has exited
	correctly (i.e. didn't segfault). Also, after this event is called, all
	plugins are removed, and their gaim_plugin_init function is called.
	This behavior is different from previous versions; however, it is the
	proper way of doing things, and should have no effect on current
	plugins. The reason event_quit exists despite plugins being removed at
	quit is because a plugin can be removed without gaim quitting. They are
	distinctly separate events.

	The new events mean that some versions of gaim have certain events,
	others don't. The thing I find fascinating though is that even if a
	plugin is compiled for a later version, it will still be backwards-
	compatible, even if it makes use of the newer events. The reason why
	is the names of the events are stored as integers, and those integers
	will never match an event in a prior version. This means you don't
	have to worry about which version the person is using, only which
	version the person is compiling against. For simplicity's sake, please
	assume people are compiling against the latest version. For
	practicality's sake, VERSION is #define'd to be the version you're
	compiling against, starting with 0.9.20. Prior versions do not have
	this defined in the standard plugin Makefile.
