---------------------------------------------------------------------------

                          Protokó³ G*du-G*du 4.x

     (C) Copyright 2001 by Wojtek Kaniewski <wojtekka@irc.pl>,
                           Robert J. Wo¼ny <speedy@atman.pl>,
                           Tomasz Jarzynka <tomee@cpi.pl>,
                           Adam Ludwikowski <adam.ludwikowski@wp.pl>,
                           Marek Kozina <klith@hybrid.art.pl>,
			   Rafa³ Florek <raf@regionet.regionet.pl>,
			   Igor Popik <igipop@wsfiz.edu.pl>

--- 0) disclaimer ---------------------------------------------------------

opis protoko³u bazuj± na do¶wiadczeniach przeprowadzonych na moim
domowym komputerze oraz informacjach przys³anych do mnie przez ró¿nych
ludzi. ¿aden klient g*du-g*du nie zosta³ skrzywdzony podczas
przeprowadzania badañ, blabla.

--- 1) transmisja, format wszystkich pakietów -----------------------------

w przeciwieñstwie do zabawek typu icq, g*du-g*du korzysta z protoko³u tcp.
ka¿dy pakiet zawiera dwa sta³e pola:

        struct gg_header {
		int type;		/* typ pakietu */
		int length;		/* d³ugo¶æ reszty pakietu */
	};

dla u³atwienia przyjmujê nastêpuj±ce d³ugo¶ci zmiennych: sizeof(char) = 1,
sizeof(short) = 2, sizeof(int) = 4. oczywi¶cie wszystkie liczby s± zgodnie
z intelowym endianem. zak³adam te¿, ¿e wszystkie zmienne s± bez znaku. nie
chce mi siê wszêdzie pisaæ `unsigned'.

pola, co do których znaczenia nie mam pewno¶ci, lub w ogóle nie mam pojêcia,
sk±d siê tam wziê³y, oznaczam `dunno'.

--- 2) zanim siê po³±czymy -------------------------------------------------

¿eby wiedzieæ, z jakim serwerem mamy siê po³±czyæ, nale¿y poudawaæ przez
chwilê Internet Explorera, po³±czyæ siê z hostem `appmsg.gadu-gadu.pl'.

        GET /appsvc/appmsg.asp?fmnumber=<tutaj_numerek_gg> HTTP/1.0
	Host: appmsg.gadu-gadu.pl
	User-Agent: Mozilla/4.7 [en] (Win98; I)
	Pragma: no-cache

oryginalny klient mo¿e wys³aæ jeden z podanych identyfikatorów przegl±darki:

	Mozilla/4.04 [en] (Win95; I ;Nav)
	Mozilla/4.7 [en] (Win98; I)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)

nowsze wersje klienta do zapytania dodaj± równie¿ `version=...' opisuj±ce,
z jakim klientem serwer ma do czynienia. jednak ze wzglêdu na mo¿liwe
ró¿nice w protokole, lepiej pomijaæ ten parametr i uwagaæ GG 4.0. w ka¿dym
razie na to zapytanie serwer powinien odpowiedzieæ:

	HTTP/1.0 200 OK
	
	0 1 0 217.17.33.21:8074 217.17.33.21 217.17.33.21

co to oznacza? nie mam pojêcia ;) wygl±da na to, ¿e ca³y g*du-g*du jest
przemy¶lany i w przysz³o¶ci bêdzie mo¿na u¿ywaæ ró¿nych serwerów do ró¿nych
rzeczy, typu szukanie, obs³uga klientów itd. póki co, ³±czyæ siê trzeba na
pierwszy adres (tak, ten z portem).
Je¿eli po³±czenie z portem 8074 nie wyjdzie z jaki¶ specyficznych powodów -
mo¿na siê ³±czyæ na port 443. 

--- 3) logowanie siê -------------------------------------------------------

po po³±czeniu siê portem serwera g*du-g*du, dostajemy pakiet typu 0x0001,
który na potrzeby tego dokumentu nazwiemy:

	#define GG_WELCOME 0x0001

reszta pakietu zawiera liczbê, na podstawie której liczony jest hash z has³a
klienta:

	struct gg_welcome {
		int key;		/* klucz szyfrowania has³a */
	};
	
kiedy mamy ju¿ t± warto¶æ mo¿emy odes³aæ pakiet logowania

	#define GG_LOGIN 0x000c

musimy podaæ kilka informacji:

	struct gg_login {
		int uin;		/* twój numerek */
		int hash;		/* hash has³a */
		int status;		/* status na dzieñ dobry */
		int version;		/* wersja klienta */
		int local_ip;		/* mój adres ip */
		short local_port;	/* port, na którym s³ucham */
	};

jak obliczyæ hash has³a? hmm... nic prostszego. do ka¿dej literki has³a
dodaje siê jedynkê, mno¿y wszystko razem, a potem przez liczbê podan± przez
serwer. 

	for (hash = 1; *passwd; passwd++)
		hash *= (*passwd) + 1;

zrozumia³e, racja? liczba oznaczaj±ca wersjê mo¿e byæ jedn± z poni¿szych:

	0x11 - 4.6.1
	0x10 - 4.5.22, 4.5.21, 4.5.19, 4.5.17, 4.5.15
	0x0f - 4.5.12
	0x0b - 4.0.30, 4.0.29, 4.0.28, 4.0.25

oczywi¶cie nie s± to wszystkie mo¿liwe wersje klientów, lecz te, które
uda³o siê sprawdziæ. najbezpieczniej bêdzie przedstawiaæ siê jako ta
wersja, której ficzerów u¿ywamy. wiadomo, ¿e 4.0.x nie obs³ugiwa³y trybu
ukrytego, ani tylko dla znajomych itd.

je¶li wszystko siê powiedzie, dostaniemy w odpowiedzi pakiet typu

	#define GG_LOGIN_OK 0x0003

z polem header->length = 0, lub pakiet
	
	#define GG_LOGIN_FAILED 0x0009

--- 4) zmiana statusu -----------------------------------------------------

g*du-g*du przewiduje trzy stany klienta, które zmieniamy pakietem

	#define GG_NEW_STATUS 0x0002

	#define GG_STATUS_NOT_AVAIL 0x0001	/* roz³±czony */
	#define GG_STATUS_AVAIL 0x0002		/* dostêpny */
	#define GG_STATUS_BUSY 0x0003		/* zajêty */
	#define GG_STATUS_INVISIBLE 0x0014	/* niewidoczny */

	#define GG_STATUS_FRIENDS_MASK 0x8000	/* tylko dla przyjació³ */
	
	struct gg_new_status {
		int status;			/* na jaki zmieniæ? */
	}

nale¿y pamiêtaæ, ¿eby przed roz³±czeniem siê z serwerem nale¿y zmieniæ
stan na GG_STATUS_NOT_AVAIL. je¶li ma byæ widoczny tylko dla przyjació³,
nale¿y dodaæ GG_STATUS_FRIENDS do normalnej warto¶ci stanu.

--- 5) ludzie przychodz±, ludzie odchodz± ---------------------------------

zaraz po zalogowaniu mo¿emy wys³aæ serwerowi listê ludzików w naszej li¶cie
kontaktów, ¿eby dowiedzieæ siê, czy s± w tej chwili dostêpni. pakiet zawiera
dowoln± ilo¶æ struktur gg_notify:

	#define GG_NOTIFY 0x0010
	
	struct gg_notify {
		int uin;		/* numerek danej osoby */
		char dunno1;		/* == 3 */
	};
	
je¶li kto¶ jest, serwer odpowie pakietem zawieraj±cym jedn± lub wiêcej
struktur gg_notify_reply:

	#define GG_NOTIFY_REPLY 0x000c	/* tak, to samo co GG_LOGIN */
	
	struct gg_notify_reply {
		int uin;		/* numerek */
		int status;		/* status danej osoby */
		int remote_ip;		/* adres ip delikwenta */
		short remote_port;	/* port, na którym s³ucha klient */
		int version;		/* wersja klienta */
		short dunno1;		/* znowu port? */
	};

je¶li klient nie obs³uguje po³±czeñ miêdzy klientami (np. g*du-g*du 3.x)
zamiast adresu ip jest 0, zamiast portu mo¿e byæ 0, 1, 2... niewa¿ne ;)
port mo¿e przyjmowaæ warto¶æ 1, je¶li klient znajduje siê za jakim¶
firewallem lub innym urz±dzeniem robi±cym NAT. w ka¿dym razie, je¶li kto¶
siê pojawi w trakcie pracy, równie¿ zostanie przys³any ten pakiet.
proste? proste :)

¿eby dodaæ kogo¶ do listy w trakcie pracy, trzeba wys³aæ ni¿ej opisany
pakiet. jego format jest identyczny jak przy GG_NOTIFY.

	#define GG_ADD 0x000d
	
	struct gg_add {
		int uin;		/* numerek */
		char dunno1;		/* == 3 */
	};

je¶li kto¶ opu¶ci g*du-g*du lub zmieni stan, otrzymamy pakiet

	#define GG_STATUS 0x0002
	
	struct gg_status {
		int uin;		/* numerek */
		int status;		/* nowy stan */
	};

--- 6) wysy³anie wiadomo¶ci ------------------------------------------------
	
przejd¼my do sedna sprawy ;)

	#define GG_SEND_MSG 0x000b

	#define GG_CLASS_QUEUED 0x0001	/* tylko przy odbieraniu */
	#define GG_CLASS_MSG 0x0004
	#define GG_CLASS_CHAT 0x0008
	#define GG_CLASS_UNKNOWN_1 0x0020

	struct gg_send_msg {
		int recipient;
		int seq;
		int class;
		char message[];
	};

wiadomo, odbiorca. numer sekwencyjny, który wykorzystujemy potem do
potwierdzenia. nie wykluczone, ¿e w jakis sposób odró¿nia siê ró¿ne
rozmowy za pomoc± czê¶ci bajtów, ale raczej nie ma znaczenia. klasa
wiadomo¶ci pozwala odró¿niæ, czy wiadomo¶æ ma siê pokazaæ w osobym
okienku czy jako kolejna linijka w okienku rozmowy. wygl±da na to,
¿e to jaka¶ bitmapa, wiêc najlepiej olaæ inne bity ni¿ 0x0e. (czasem
klienty wysy³aj± 0x04, czasem 0x24 -- widocznie 0x20 to te¿ jaka¶
flaga). je¶li odbiorca by³ niedostêpny podczas wysy³ania wiadomo¶ci,
zostanie zaznaczony bit 0x01.

oryginalny klient wysy³aj±c wiadomo¶æ do kilku u¿ytkowników, wysy³a po
prostu kilka takich samych pakietów z ró¿nymi numerkami odbiorców. nie
ma osobnego pakietu do tego. natomiast je¶li chodzi o ,,konferencyjnê''
do pakietu doklejana jest za ,,char message[];'' nastêpuj±ca struktura:

	struct gg_send_recipients {
		char flag;		/* == 1 */
		int count;		/* ilo¶æ odbiorców */
		int recipients[];	/* tablica odbiorców */
	};

na przyk³ad, by wys³aæ do trzech ludzi, nale¿y wys³aæ pakiet:

	- -- --- --+--+--+--+--+--+--+-----------+-----------+
          tre¶æ    |\0|\1|    0x02   |    uin1   |   uin2    |
	- -- -- ---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

serwer po otrzymaniu wiadomo¶ci odsy³a informacjê o tym. przy okazji
mówi, czy wiadomo¶æ dotar³a do odbiorcy (status == GG_ACK_DELIVERED),
czy mo¿e jest offline i zosta³a zakolejkowana (GG_ACK_QUEUED):

	#define GG_SEND_MSG_ACK 0x0005
	
	#define GG_ACK_DELIVERED 0x0002
	#define GG_ACK_QUEUED 0x0003

	struct gg_send_msg_ack {
		int status;
		int recipient;
		int seq;
	};

numer sekwencyjny i adresat ten sam, co przy wysy³aniu.

--- 7) otrzymywanie wiadomo¶ci ---------------------------------------------

zbyt wiele wyja¶nieñ chyba nie trzeba. wiadomo od kogo. drugie pole to
najprawdopodobniej jaki¶ numerek sekwencyjny. trzecie oznacza czas nadania
wiadomo¶ci. klasa wiadomo¶ci taka sama jak przy wysy³aniu:

	#define GG_RECV_MSG 0x000a
	
	struct gg_recv_msg {
		int sender;
		int seq;
		int time;
		int class;
		char message[];
	};

w przypadku pakietów ,,konferencyjnych'' na koncu pakietu doklejona jest
struktura identyczna ze struct gg_send_recipients zawieraj±ca pozosta³ych
rozmówców.

--- 8) ping/pong -----------------------------------------------------------

od czasu do czasu klient wysy³a pakiet a'la ping do serwera i dostaje pust±
odpowied¼. o ile dobrze pamiêtam, serwer roz³±cza siê po up³ywie 5 minut od
otrzymania ostatniej informacji.

	#define GG_PING 0x0008
	
	/* nie ma niczego */
	
	#define GG_PONG 0x0007
	
	/* nie ma niczego */

--- 9) podziêkowania -------------------------------------------------------

swój wk³ad w poznanie protoko³u mieli:
 - Robert J. Wo¼ny <speedy@atman.pl>:
   opis nowo¶ci w protokole GG 4.6,
 - Tomasz Jarzynka <tomee@cpi.pl>:
   badanie timeoutów,
 - Adam Ludwikowski <adam.ludwikowski@wp.pl>:
   wiele ró¿nych poprawek do tekstu, badanie wersji,
 - Marek Kozina <klith@hybrid.art.pl>:
   czas otrzymania wiadomo¶ci,
 - Rafa³ Florek <raf@regionet.regionet.pl>:
   konferencje,
 - Igor Popik <igipop@wsfiz.edu.pl>:
   klasy wiadomo¶ci przy odbieraniu zakolejkowanej.

----------------------------------------------------------------------------

