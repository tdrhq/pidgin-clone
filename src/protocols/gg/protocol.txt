---------------------------------------------------------------------------

                         protokó³ g*du-g*du 4.x
        (c) copyright 2001 by wojtek kaniewski <wojtekka@irc.pl>

--- 0) disclaimer ---------------------------------------------------------

wszystkie informacje bazuj± na do¶wiadczeniach przeprowadzonych na moim
domowym komputerze. ¿aden klient g*du-g*du nie zosta³ skrzywdzony podczas
przeprowadzania badañ, blabla.

--- 1) transmisja, format wszystkich pakietów -----------------------------

w przeciwieñstwie do zabawek typu icq, g*du-g*du korzysta z protoko³u tcp.
ka¿dy pakiet zawiera dwa sta³e pola:

        struct gg_header {
		int type;		/* typ pakietu */
		int length;		/* d³ugo¶æ reszty pakietu */
	};

dla u³atwienia przyjmujê nastêpuj±ce d³ugo¶ci zmiennych: sizeof(char) = 1,
sizeof(short) = 2, sizeof(int) = 4. oczywi¶cie wszystkie liczby s± zgodnie
z intelowym endianem. zak³adam te¿, ¿e wszystkie zmienne s± bez znaku. nie
chce mi siê wszêdzie pisaæ `unsigned'.

pola, co do których znaczenia nie mam pewno¶ci, lub w ogóle nie mam pojêcia,
sk±d siê tam wziê³y, oznaczam `dunno'.

--- 2) zanim siê po³±czymy -------------------------------------------------

¿eby wiedzieæ, z jakim serwerem mamy siê po³±czyæ, nale¿y poudawaæ przez
chwilê Internet Explorera, po³±czyæ siê z hostem `appmsg.gadu-gadu.pl'.

        GET /appsvc/appmsg.asp?fmnumber=<tutaj_numerek_gg> HTTP/1.0
	Host: appmsg.gadu-gadu.pl
	User-Agent: Mozilla/4.7 [en] (Win98; I)
	Pragma: no-cache

na co powinni¶my dostaæ odpowied¼ w stylu:

	HTTP/1.0 200 OK
	
	0 1 0 217.17.33.21:8074 217.17.33.21 217.17.33.21

co to oznacza? nie mam pojêcia ;) wygl±da na to, ¿e ca³y g*du-g*du jest
przemy¶lany i w przysz³o¶ci bêdzie mo¿na u¿ywaæ ró¿nych serwerów do ró¿nych
rzeczy, typu szukanie, obs³uga klientów itd. póki co, ³±czyæ siê trzeba na
pierwszy adres (tak, ten z portem).

--- 3) logowanie siê -------------------------------------------------------

po po³±czeniu siê portem 8074 serwera g*du-g*du, dostajemy pakiet typu 0x0001,
który na potrzeby tego dokumentu nazwiemy:

	#define GG_WELCOME 0x0001

reszta pakietu zawiera liczbê, na podstawie której liczony jest hash z has³a
klienta:

	struct gg_welcome {
		int key;		/* klucz szyfrowania has³a */
	};
	
kiedy mamy ju¿ t± warto¶æ mo¿emy odes³aæ pakiet logowania

	#define GG_LOGIN 0x000c

musimy podaæ kilka informacji:

	struct gg_login {
		int uin;		/* twój numerek */
		int hash;		/* hash has³a */
		int status;		/* status na dzieñ dobry */
		int dunno1;		/* == 0x0b */
		int local_ip;		/* mój adres ip */
		short local_port;	/* port, na którym s³ucham */
	};

jak obliczyæ hash has³a? hmm... nic prostszego. do ka¿dej literki has³a
dodaje siê jedynkê, mno¿y wszystko razem, a potem przez liczbê podan± przez
serwer. 

	for (hash = 1; *passwd; passwd++)
		hash *= (*passwd) + 1;

zrozumia³e, racja? je¶li wszystko siê powiedzie, dostaniemy w odpowiedzi
pakiet typu

	#define GG_LOGIN_OK 0x0003

z polem header->length = 0, lub pakiet
	
	#define GG_LOGIN_FAILED 0x0009

--- 4) zmiana statusu -----------------------------------------------------

g*du-g*du przewiduje trzy stany klienta, które zmieniamy pakietem

	#define GG_NEW_STATUS 0x0002

	#define GG_STATUS_NOT_AVAIL 0x0001	/* roz³±czony */
	#define GG_STATUS_AVAIL 0x0002		/* dostêpny */
	#define GG_STATUS_BUSY 0x0003		/* zajêty */
	#define GG_STATUS_INVISIBLE 0x0014	/* niewidoczny */

	#define GG_STATUS_FRIENDS_MASK 0x8000	/* tylko dla przyjació³ */
	
	struct gg_new_status {
		int status;			/* na jaki zmieniæ? */
	}

nale¿y pamiêtaæ, ¿eby przed roz³±czeniem siê z serwerem nale¿y zmieniæ
stan na GG_STATUS_NOT_AVAIL. je¶li ma byæ widoczny tylko dla przyjació³,
nale¿y dodaæ GG_STATUS_FRIENDS do normalnej warto¶ci stanu.

--- 5) ludzie przychodz±, ludzie odchodz± ---------------------------------

zaraz po zalogowaniu mo¿emy wys³aæ serwerowi listê ludzików w naszej li¶cie
kontaktów, ¿eby dowiedzieæ siê, czy s± w tej chwili dostêpni. pakiet zawiera
dowoln± ilo¶æ struktur gg_notify:

	#define GG_NOTIFY 0x0010
	
	struct gg_notify {
		int uin;		/* numerek danej osoby */
		char dunno1;		/* == 3 */
	};
	
je¶li kto¶ jest, serwer odpowie pakietem zawieraj±cym jedn± lub wiêcej
struktur gg_notify_reply:

	#define GG_NOTIFY_REPLY 0x000c	/* tak, to samo co GG_LOGIN */
	
	struct gg_notify_reply {
		int uin;		/* numerek */
		int status;		/* status danej osoby */
		int remote_ip;		/* adres ip delikwenta */
		short remote_port;	/* port, na którym s³ucha klient */
		int dunno1;		/* == 0x0b */
		short dunno2;		/* znowu port? */
	};

je¶li klient nie obs³uguje po³±czeñ miêdzy klientami (np. g*du-g*du 3.x)
zamiast adresu ip jest 0, zamiast portu jest 2. niewa¿ne ;) w ka¿dym razie,
je¶li kto¶ siê pojawi w trakcie pracy, równie¿ zostanie przys³any ten
pakiet. proste? proste :)

¿eby dodaæ kogo¶ do listy w trakcie pracy, trzeba wys³aæ ni¿ej opisany
pakiet. jego format jest identyczny jak przy GG_NOTIFY.

	#define GG_ADD 0x000d
	
	struct gg_add {
		int uin;		/* numerek */
		char dunno1;		/* == 3 */
	};

je¶li kto¶ opu¶ci g*du-g*du lub zmieni stan, otrzymamy pakiet

	#define GG_STATUS 0x0002
	
	struct gg_status {
		int uin;		/* numerek */
		int status;		/* nowy stan */
	};

--- 6) wysy³anie wiadomo¶ci ------------------------------------------------
	
przejd¼my do sedna sprawy ;)

	#define GG_SEND_MSG 0x000b

	#define GG_CLASS_MSG 0x0004
	#define GG_CLASS_CHAT 0x0008

	struct gg_send_msg {
		int recipient;
		int seq;
		int class;
		char message[];
	};

wiadomo, odbiorca. numer sekwencyjny, który wykorzystujemy potem do
potwierdzenia. nie wykluczone, ¿e w jakis sposób odró¿nia siê ró¿ne
rozmowy za pomoc± czê¶ci bajtów, ale raczej nie ma znaczenia. klasa
wiadomo¶ci pozwala odró¿niæ, czy wiadomo¶æ ma siê pokazaæ w osobym
okienku czy jako kolejna linijka w okienku rozmowy. wygl±da na to,
¿e to jaka¶ bitmapa, wiêc najlepiej olaæ inne bity ni¿ 0x0f. (czasem
klienty wysy³aj± 0x04, czasem 0x24)

serwer po otrzymaniu wiadomo¶ci odsy³a informacjê o tym. przy okazji
mówi, czy wiadomo¶æ dotar³a do odbiorcy (status == GG_ACK_DELIVERED),
czy mo¿e jest offline i zosta³a zakolejkowana (GG_ACK_QUEUED):

	#define GG_SEND_MSG_ACK 0x0005
	
	#define GG_ACK_DELIVERED 0x0002
	#define GG_ACK_QUEUED 0x0003

	struct gg_send_msg_ack {
		int status;
		int recipient;
		int seq;
	};

numer sekwencyjny i adresat ten sam, co przy wysy³aniu.

--- 7) otrzymywanie wiadomo¶ci ---------------------------------------------

zbyt wiele wyja¶nieñ chyba nie trzeba. wiadomo od kogo. nieznane pola to
co¶ a'la numer sekwencyjny albo identyfikator okienka z rozmow± albo nowe
dane dla setiathome. klasa wiadomo¶ci taka sama jak przy wysy³aniu:

	#define GG_RECV_MSG 0x000a
	
	struct gg_recv_msg {
		int sender;
		int dunno1;
		int dunno2;
		int class;
		char message[];
	};

--- 8) otrzymywanie wiadomo¶ci ---------------------------------------------

od czasu do czasu klient wysy³a pakiet a'la ping do serwera i dostaje pust±
odpowied¼. ciê¿ko stwierdziæ, czy serwer wywala, je¶li nie dostanie pinga
przez jaki¶ czas, czy klient siê roz³±cza, je¶li serwer mu nie odpowie.
jako¶ nie chce mi siê sprawdzaæ ;)

	#define GG_PING 0x0008
	
	/* nie ma niczego */
	
	#define GG_PONG 0x0007
	
	/* nie ma niczego */

--- 9) podziêkowania -------------------------------------------------------

swój wk³ad w poznanie protoko³u mia³ Robert Wo¼ny, który opisa³ nowo¶ci
w GG 4.6.

----------------------------------------------------------------------------

$Id: protocol.txt 2406 2001-09-29 23:06:30Z warmenhoven $

